import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.BNO055IMU;
import com.qualcomm.robotcore.hardware.BNO055IMU.Parameters;

public class MecanumDriveOpMode extends OpMode {
    private DcMotor frontLeft, frontRight, backLeft, backRight;
    private BNO055IMU imu;
    private double robotHeading;

    private double lastX = 0, lastY = 0;

    @Override
    public void init() {
        // Initialize motors
        frontLeft = hardwareMap.get(DcMotor.class, "front_left");
        frontRight = hardwareMap.get(DcMotor.class, "front_right");
        backLeft = hardwareMap.get(DcMotor.class, "back_left");
        backRight = hardwareMap.get(DcMotor.class, "back_right");

        frontLeft.setDirection(DcMotor.Direction.FORWARD);
        frontRight.setDirection(DcMotor.Direction.REVERSE);
        backLeft.setDirection(DcMotor.Direction.FORWARD);
        backRight.setDirection(DcMotor.Direction.REVERSE);

        // Initialize IMU with correct settings
        imu = hardwareMap.get(BNO055IMU.class, "imu");
        Parameters parameters = new Parameters();
        parameters.angleUnit = BNO055IMU.AngleUnit.DEGREES;
        parameters.mode = BNO055IMU.SensorMode.IMU;
        parameters.loggingEnabled = false;
        imu.initialize(parameters);
    }

    @Override
    public void loop() {
        // Get robot heading in radians
        robotHeading = Math.toRadians(imu.getAngularOrientation().firstAngle);

        // Get joystick inputs
        double y = -gamepad1.left_stick_y;
        double x = gamepad1.left_stick_x;
        double rotation = gamepad1.right_stick_x;

        // Deadzone
        double deadZone = 0.05;
        if (Math.abs(x) < deadZone) x = 0;
        if (Math.abs(y) < deadZone) y = 0;
        if (Math.abs(rotation) < deadZone) rotation = 0;

        // Apply input curve
        double curveFactor = 2.0;
        x = Math.signum(x) * Math.pow(Math.abs(x), curveFactor);
        y = Math.signum(y) * Math.pow(Math.abs(y), curveFactor);

        // Smooth input
        double smoothingFactor = 0.25;
        double smoothX = lastX * (1 - smoothingFactor) + x * smoothingFactor;
        double smoothY = lastY * (1 - smoothingFactor) + y * smoothingFactor;
        lastX = smoothX;
        lastY = smoothY;

        // Field-centric transform
        double fieldCentricX = smoothX * Math.cos(robotHeading) - smoothY * Math.sin(robotHeading);
        double fieldCentricY = smoothX * Math.sin(robotHeading) + smoothY * Math.cos(robotHeading);

        // Rotation directly scaled
        double rotationScaled = rotation * 0.6;

        // Mecanum drive calculations
        double frontLeftPower = fieldCentricY + fieldCentricX + rotationScaled;
        double frontRightPower = fieldCentricY - fieldCentricX - rotationScaled;
        double backLeftPower = fieldCentricY - fieldCentricX + rotationScaled;
        double backRightPower = fieldCentricY + fieldCentricX - rotationScaled;

        // Normalize if needed
        double max = Math.max(Math.abs(frontLeftPower), Math.max(Math.abs(frontRightPower),
                Math.max(Math.abs(backLeftPower), Math.abs(backRightPower))));
        if (max > 1.0) {
            frontLeftPower /= max;
            frontRightPower /= max;
            backLeftPower /= max;
            backRightPower /= max;
        }

        // Set motor powers
        frontLeft.setPower(frontLeftPower);
        frontRight.setPower(frontRightPower);
        backLeft.setPower(backLeftPower);
        backRight.setPower(backRightPower);

        // Telemetry
        telemetry.addData("Heading (deg)", Math.toDegrees(robotHeading));
        telemetry.addData("FL", frontLeftPower);
        telemetry.addData("FR", frontRightPower);
        telemetry.addData("BL", backLeftPower);
        telemetry.addData("BR", backRightPower);
        telemetry.update();
    }
}
