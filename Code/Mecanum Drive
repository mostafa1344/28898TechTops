import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.Gamepad;
import com.qualcomm.robotcore.hardware.HardwareMap;
import com.qualcomm.robotcore.hardware.BNO055IMU;
import com.qualcomm.robotcore.hardware.BNO055IMU.Parameters;

public class MecanumDriveOpMode extends OpMode {
    // Declare motors and IMU sensor
    private DcMotor frontLeft, frontRight, backLeft, backRight;
    private BNO055IMU imu;

    // Initialize the IMU heading variable
    private double robotHeading;
    private double lastX = 0, lastY = 0;

    // PID variables for rotation control
    private double kP = 0.1, kI = 0.01, kD = 0.01;
    private double previousError = 0, integral = 0;

    @Override
    public void init() {
        // Initialize motors
        frontLeft = hardwareMap.get(DcMotor.class, "front_left");
        frontRight = hardwareMap.get(DcMotor.class, "front_right");
        backLeft = hardwareMap.get(DcMotor.class, "back_left");
        backRight = hardwareMap.get(DcMotor.class, "back_right");

        // Set motor directions
        frontLeft.setDirection(DcMotor.Direction.FORWARD);
        frontRight.setDirection(DcMotor.Direction.REVERSE);
        backLeft.setDirection(DcMotor.Direction.FORWARD);
        backRight.setDirection(DcMotor.Direction.REVERSE);

        // Initialize IMU (Gyroscope)
        imu = hardwareMap.get(BNO055IMU.class, "imu");
        Parameters parameters = new Parameters();
        imu.initialize(parameters);

        // Initialize heading
        robotHeading = 0.0;
    }

    @Override
    public void loop() {
        // Update the robot's heading from the IMU
        robotHeading = imu.getAngularOrientation().firstAngle;

        // Get joystick input from the gamepad
        double y = -gamepad1.left_stick_y;  // Invert the y-axis for intuitive control
        double x = gamepad1.left_stick_x;
        double rotation = gamepad1.right_stick_x;

        // Apply dead zone threshold for smoother control
        double deadZone = 0.05;  // Adjust as needed
        if (Math.abs(x) < deadZone) x = 0;
        if (Math.abs(y) < deadZone) y = 0;
        if (Math.abs(rotation) < deadZone) rotation = 0;

        // Apply exponential curve to joystick input for smoother control
        double curveFactor = 2.0; // Higher values give more sensitivity at higher speeds
        x = Math.pow(x, curveFactor);
        y = Math.pow(y, curveFactor);

        // Apply smoothing to joystick input
        double smoothingFactor = 0.1;  // Adjust for desired smoothness
        double smoothX = (lastX * (1 - smoothingFactor)) + (x * smoothingFactor);
        double smoothY = (lastY * (1 - smoothingFactor)) + (y * smoothingFactor);
        lastX = smoothX;
        lastY = smoothY;

        // Field-Centric Mecanum Drive
        double fieldCentricX = smoothX * Math.cos(robotHeading) - smoothY * Math.sin(robotHeading);
        double fieldCentricY = smoothX * Math.sin(robotHeading) + smoothY * Math.cos(robotHeading);

        // PID correction for rotation
        double rotationCorrection = getPIDCorrection(rotation);

        // Set power to the motors
        double frontLeftPower = fieldCentricY + fieldCentricX + rotationCorrection;
        double frontRightPower = fieldCentricY - fieldCentricX - rotationCorrection;
        double backLeftPower = fieldCentricY - fieldCentricX + rotationCorrection;
        double backRightPower = fieldCentricY + fieldCentricX - rotationCorrection;

        // Normalize motor power values to ensure they stay within -1 to 1
        double max = Math.max(Math.abs(frontLeftPower), Math.max(Math.abs(frontRightPower),
                Math.max(Math.abs(backLeftPower), Math.abs(backRightPower))));
        if (max > 1.0) {
            frontLeftPower /= max;
            frontRightPower /= max;
            backLeftPower /= max;
            backRightPower /= max;
        }

        // Apply power to the motors
        frontLeft.setPower(frontLeftPower);
        frontRight.setPower(frontRightPower);
        backLeft.setPower(backLeftPower);
        backRight.setPower(backRightPower);
    }

    // PID controller function for heading correction
    public double getPIDCorrection(double targetHeading) {
        double error = targetHeading - robotHeading;
        integral += error;
        double derivative = error - previousError;
        double correction = kP * error + kI * integral + kD * derivative;
        previousError = error;
        return correction;
    }
}
