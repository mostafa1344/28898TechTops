import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.Gamepad;
import com.qualcomm.robotcore.hardware.HardwareMap;
import com.qualcomm.robotcore.hardware.BNO055IMU;
import com.qualcomm.robotcore.hardware.BNO055IMU.Parameters;

public class MecanumDriveOpMode extends OpMode {
    private DcMotor frontLeft, frontRight, backLeft, backRight;
    private BNO055IMU imu;
    private double robotHeading;

    private double lastX = 0, lastY = 0;
    private double lastFrontLeftPower = 0, lastFrontRightPower = 0, lastBackLeftPower = 0, lastBackRightPower = 0;

    private double kP = 0.1, kI = 0.01, kD = 0.01;
    private double previousError = 0, integral = 0;

    @Override
    public void init() {
        // Initialize motors
        frontLeft = hardwareMap.get(DcMotor.class, "front_left");
        frontRight = hardwareMap.get(DcMotor.class, "front_right");
        backLeft = hardwareMap.get(DcMotor.class, "back_left");
        backRight = hardwareMap.get(DcMotor.class, "back_right");

        frontLeft.setDirection(DcMotor.Direction.FORWARD);
        frontRight.setDirection(DcMotor.Direction.REVERSE);
        backLeft.setDirection(DcMotor.Direction.FORWARD);
        backRight.setDirection(DcMotor.Direction.REVERSE);

        // Initialize IMU
        imu = hardwareMap.get(BNO055IMU.class, "imu");
        Parameters parameters = new Parameters();
        imu.initialize(parameters);

        robotHeading = 0.0;
    }

    @Override
    public void loop() {
        // Get the robot's current heading from the IMU
        robotHeading = imu.getAngularOrientation().firstAngle;

        // Get joystick inputs
        double y = -gamepad1.left_stick_y;  // Invert the y-axis for intuitive control
        double x = gamepad1.left_stick_x;
        double rotation = gamepad1.right_stick_x;

        // Apply deadzone
        double deadZone = 0.05;
        if (Math.abs(x) < deadZone) x = 0;
        if (Math.abs(y) < deadZone) y = 0;
        if (Math.abs(rotation) < deadZone) rotation = 0;

        // Smooth the joystick inputs
        double curveFactor = 2.0;
        x = Math.pow(x, curveFactor);
        y = Math.pow(y, curveFactor);

        double smoothingFactor = 0.1;
        double smoothX = (lastX * (1 - smoothingFactor)) + (x * smoothingFactor);
        double smoothY = (lastY * (1 - smoothingFactor)) + (y * smoothingFactor);
        lastX = smoothX;
        lastY = smoothY;

        // Convert joystick inputs to field-centric control
        double fieldCentricX = smoothX * Math.cos(robotHeading) - smoothY * Math.sin(robotHeading);
        double fieldCentricY = smoothX * Math.sin(robotHeading) + smoothY * Math.cos(robotHeading);

        // Get rotation correction using PID controller
        double rotationCorrection = getPIDCorrection(rotation);

        // Calculate motor powers
        double frontLeftPower = fieldCentricY + fieldCentricX + rotationCorrection;
        double frontRightPower = fieldCentricY - fieldCentricX - rotationCorrection;
        double backLeftPower = fieldCentricY - fieldCentricX + rotationCorrection;
        double backRightPower = fieldCentricY + fieldCentricX - rotationCorrection;

        // Normalize motor powers if any exceeds the max value of 1
        double max = Math.max(Math.abs(frontLeftPower), Math.max(Math.abs(frontRightPower),
                Math.max(Math.abs(backLeftPower), Math.abs(backRightPower))));
        if (max > 1.0) {
            frontLeftPower /= max;
            frontRightPower /= max;
            backLeftPower /= max;
            backRightPower /= max;
        }

        // Set motor powers
        frontLeft.setPower(frontLeftPower);
        frontRight.setPower(frontRightPower);
        backLeft.setPower(backLeftPower);
        backRight.setPower(backRightPower);

        // Telemetry for debugging
        telemetry.addData("Heading", robotHeading);
        telemetry.addData("Motor FL", frontLeft.getPower());
        telemetry.addData("Motor FR", frontRight.getPower());
        telemetry.addData("Motor BL", backLeft.getPower());
        telemetry.addData("Motor BR", backRight.getPower());
        telemetry.update();
    }

    // PID controller for rotation correction
    public double getPIDCorrection(double targetHeading) {
        double error = targetHeading - robotHeading;
        integral += error;
        double derivative = error - previousError;
        double correction = kP * error + kI * integral + kD * derivative;
        previousError = error;
        return correction;
    }
}
